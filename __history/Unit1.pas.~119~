unit Unit1;

interface

uses
	Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
	Dialogs, StdCtrls, ExtCtrls, ComCtrls, Math, Buttons, Menus, Tabs, DockTabSet;

type
		TNewImage = class(TImage)

		end;
	TForm1 = class(TForm)
    Image1: TImage;
    OpenDialog1: TOpenDialog;
    TrackBar1: TTrackBar;
    Label1: TLabel;
    Panel1: TPanel;
    Panel2: TPanel;
    CheckBox1: TCheckBox;
    CheckBox2: TCheckBox;
    SpeedButton1: TSpeedButton;
    SpeedButton2: TSpeedButton;
    Image2: TImage;
    MainMenu1: TMainMenu;
    File1: TMenuItem;
    Open1: TMenuItem;
    N1: TMenuItem;
    Exit1: TMenuItem;
    View1: TMenuItem;
    Frequencyanalysis1: TMenuItem;
    Controls1: TMenuItem;
    Panel3: TPanel;
    SpeedButton3: TSpeedButton;
    TabControl1: TTabControl;
    ComboBox1: TComboBox;
    procedure SpeedButton3Click(Sender: TObject);
    procedure Exit1Click(Sender: TObject);
    procedure Image1Click(Sender: TObject);
    procedure Image1MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure Image1MouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure Image1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure SpeedButton2Click(Sender: TObject);
    procedure SpeedButton1Click(Sender: TObject);
    procedure CheckBox2Click(Sender: TObject);
		procedure CheckBox1Click(Sender: TObject);
		procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure Image1MouseEnter(Sender: TObject);
    procedure Panel2MouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure Panel2MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure Panel2MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure FormCreate(Sender: TObject);
    procedure TrackBar1Change(Sender: TObject);
		procedure Button1Click(Sender: TObject);
  private
		dragging: boolean;
		procedure OnWheel(var Msg: TMessage); message WM_MOUSEWHEEL;
	public
		procedure draw(zoomOut: real);
		procedure BarPlot(slice, blockSize: integer);
		procedure getSettings;
	end;
type TFrequency = array[0..255] of int64;
type TMarker = record
	position: integer;
	left,right: integer;
	Fixed		:	Boolean;
end;
function  Frequency_analysis(data: PAnsiString; shift,count: integer):TFrequency; inline;
function  load_file(Path:string; resultPTR: PAnsiString):boolean;

function getAbsolutePos(screenPos: integer): integer; inline;
function getBlockSize: integer; inline;

const UpdateInterval = 500; //100 ms
			magicConstant	 = 256;
var
	Form1: TForm1;
	_File: TFileStream;
	binary_data: AnsiString;
	shift: cardinal;
	oldShift: cardinal = 0;
	dragStart: integer;
	marker			: TMarker;
	bitmap,bitmap2 :	TBitmap;
	ExBitmap2		: Array [0..255] of array [0..636] of TColor;
	showMax			:	boolean = false;
	antiAlias		:	boolean = true;
implementation

uses Threads;

{$R *.dfm}

procedure TForm1.getSettings;
begin
	showMax := CheckBox1.Checked;
	antiAlias := CheckBox2.Checked;
end;

function getAbsolutePos(screenPos: integer): integer;
begin
	result := trunc(shift*256 + screenPos*Math.Power(2,form1.trackbar1.Position)*256);
end;

function getBlockSize: integer;
begin
	result := trunc(Math.Power(2,form1.trackbar1.Position)*magicConstant);
end;

procedure TForm1.OnWheel(var Msg: TMessage);
var shiftDelta, t0: cardinal;
tmp: boolean;
begin
	getSettings;
	if trackbar1.Position < trackbar1.Max then begin
		shiftDelta := trunc(Math.power(2, trackbar1.Position)) shl 6;
		if trackbar1.Position < 0 then
			shiftDelta := trunc(Math.power(2, 8+trackbar1.Position));
	with panel2 do begin
		if (msg.WParamHi = $FF88) then
		 //	if ((shift+shiftDelta+math.Power(2, trackbar1.Position)*640)*256 < length(binary_data)) then
			inc(shift,shiftDelta) else
			 //	shift := trunc((length(binary_data) - math.power(2, trackbar1.Position)*256*(image1.Width+shiftDelta))/256);
		if (msg.WParamHi = $0078) then
			if (shift >= shiftDelta) then
				dec(shift,shiftDelta)
			else
				shift := 0;
		if trackbar1.Position = trackbar1.Max then
			shift := 0;
		t0 := gettickcount;
		if oldShift<>shift then begin
			oldShift := shift;
			draw(trackbar1.Position);
		end;
		t0 := gettickcount - t0;
		panel2.Left := trunc(panel1.Width*(shift*magicConstant/length(binary_data)));
		with panel2 do
			if left > panel1.Width - width  then
				left := panel1.Width - width;
			form1.Caption := 	floattostr((unit1.shift)*magicConstant/length(binary_data))+' - '+
											floattostr((unit1.shift+trunc(Math.power(2,trackbar1.Position)*640))*magicConstant/length(binary_data))+
											' - '+inttostr(t0)+'ms';
	end;
	BarPlot(0,getBlockSize);
	end;
	inherited;  //save descriptor
end;

procedure TForm1.Button1Click(Sender: TObject);
var width,zoomOut: integer;
begin
if OpenDialog1.execute then begin
	load_file(OpenDialog1.FileName, @binary_data);
	zoomOut := 0; shift := 0;
	trackbar1.onchange := nil;
	while Math.Power(2, zoomOut)*magicConstant*image1.Width < length(binary_data) do
		inc(zoomOut);
	trackbar1.Max := zoomOut;
	trackbar1.Position := zoomOut;
	getSettings;
	draw(trackbar1.Position);
	trackbar1.onchange := TrackBar1Change;
	draw(trackbar1.Position);
	BarPlot(0, getBlockSize);
end;

end;

function  Frequency_analysis(data: PAnsiString; shift,count: integer):TFrequency;
var
	_length : integer;
	i				: integer;
begin
	for I := 0 to 255 do
		result[i] := 0;
	_length 	:= length(data^);
	if shift > _length then
		EXIT;
	if shift + count > _length then
		EXIT;
	for i := shift to shift+count do
		inc(result[ord(data^[i])]);
end;

procedure TForm1.TrackBar1Change(Sender: TObject);
begin
		if trackbar1.Position = trackbar1.Max then
			shift := 0;
panel2.Left := trunc(panel1.Width*(shift*magicConstant/length(binary_data)));
panel2.Width := trunc(Math.Power(2,trackbar1.position)*magicConstant*640/length(binary_data)*panel1.Width);
form1.Caption := 	floattostr((shift)*magicConstant/length(binary_data))+' - '+
											floattostr((shift+trunc(Math.power(2,trackbar1.Position)*640*magicConstant))/length(binary_data));
if binary_data<>'' then
	draw(trackbar1.Position);
label1.Caption := 'Zoom out '+inttostr(trunc(Math.power(2,trackbar1.Position)))+'x';
end;

function load_file(Path:string; resultPTR: PAnsiString):boolean;
var _file			:	file;
		I					:	integer;
		i2				:	integer;
		file_size	: integer;
		buf				:	array[0..4095] of byte;
		oneByte		:	AnsiChar;
begin
			assignfile(_file,Path);
			FileMode := fmOpenRead;
			try
			try
      	resultPTR^ := '';
				reset(_file,1);
				file_size := fileSize(_file);
				setLength(resultPTR^, file_size);
				reset(_file,4096);
				for i:=0 to fileSize(_file)-1 do begin
					blockRead(_file,buf,1);
					for I2 := 0 to 4095 do
						resultPTR^[i * 4096 + i2 + 1] := chr(buf[i2]);
				end;
				reset(_file,1);
				seek(_file,trunc(file_size / 4096) * 4096);
				while not eof(_file) do begin
					blockread(_file,oneByte,1);
					resultPTR^[filePos(_file)] := oneByte;
				end;
				Result:=true;
				except
					setLength(resultPTR^,0);
					Result:=false;
					MessageBox(	form1.Handle,
											PChar('Недостаточно памяти.'),
											PChar('Error!'),
											MB_ICONSTOP+MB_OK);
				end;
      finally
				closefile(_file);
			end;
end;

procedure TForm1.CheckBox1Click(Sender: TObject);
begin
showMax :=  CheckBox1.Checked;
draw(trackbar1.Position);
end;

procedure TForm1.CheckBox2Click(Sender: TObject);
begin
	antiAlias := checkBox2.Checked;
	ComboBox1.Enabled := checkbox2.Checked;
	draw(trackbar1.Position);
end;

procedure TForm1.draw(zoomOut: real);
var i2,i3,max		:	integer;
		i : real;
		buf					: AnsiString;
		frequency 	: TFrequency;
		scale				: extended;
		Tmp					: byte;
		_FileSize		: integer;
		blockCnt		: real;
		optVar1			:	integer;
		ptr					: pointer;
		shift				:	cardinal;
		maxAntiAlias: integer;
begin
	if binary_data = '' then exit;
	shift := unit1.shift;
	maxAntiAlias := trunc(math.Power(2,combobox1.ItemIndex + 4))*magicConstant;
	marker.position := 640;
	zoomOut:= Math.power(2,zoomOut);
	_FileSize := length(binary_data);
	if zoomOut < 1 then
		antiAlias := not checkBox2.Checked;
	//shift := trunc(panel2.Left/panel1.Width*_FileSize/256);
	blockCnt :=  _Filesize div magicConstant;
	if zoomOut < 1 then
		blockCnt :=  _Filesize div trunc(magicConstant*zoomOut);
	//if zoomOut>=1 then

	if blockcnt > image1.Width*zoomOut then
		blockcnt := image1.Width*zoomOut;
	if shift>(_Filesize div magicConstant)-zoomOut*640 then
		shift := trunc((_Filesize div magicConstant)-zoomOut*640);
	for I3 := 0 to 255 do
		for I2 := 0 to 639 do
			Exbitmap2[i3][i2] := 0;
	if zoomOut*640*magicConstant > _FileSize then
	begin
		Shift := 0;
	end;
	I:=shift;
	while I-shift < blockCnt do begin
		buf:='';
		if (i*magicConstant > _FileSize) then
			break;
		//for I2 := 0 to 255 do
			//buf := buf + binary_data[(i)*256 + i2];
		if antiAlias and (trunc(magicConstant*zoomOut) > maxAntiAlias) then
			frequency := Frequency_Analysis(@binary_data, trunc(i*magicConstant), maxAntiAlias)
		else
		if antiAlias then
			frequency := Frequency_Analysis(@binary_data, trunc(i*magicConstant),trunc(magicConstant*zoomOut))
		else
			frequency := Frequency_Analysis(@binary_data, trunc(i*magicConstant),magicConstant);
		max := 0;
		for I2 := 0 to 255 do
			if max<frequency[i2] then
				max:=frequency[i2];
		if max <= 0 then begin
			//showMessage('Error!');
			I := i + zoomOut;
			continue;
    end;
		scale:=1/max;
		optVar1 := trunc((I-shift)/zoomOut);
		if optVar1 > 639 then
			optVar1 := 639;
		for I2 := 0 to 255 do begin
			tmp := trunc(frequency[i2]*scale*$FF);
			if showMax and (frequency[i2] = max) then
				ExBitmap2[255-i2,optVar1] := tmp shl 16
			else
				ExBitmap2[255-i2,optVar1] := (tmp shl 16) + (tmp shl 8) + tmp;
			//bitmap.Canvas.Pixels[,255-i2] := (tmp shl 16) + (tmp shl 8) + tmp;
		end;
		I := i + zoomOut;
	end;

	for I3 := 0 to 255 do begin
		ptr := bitmap.ScanLine[i3];
		Move(ExBitmap2[i3],ptr^, 640*4);
	end;
	image1.Picture.Bitmap.Assign(bitmap);
end;

procedure TForm1.Exit1Click(Sender: TObject);
begin
Close;
end;

procedure TForm1.FormClose(Sender: TObject; var Action: TCloseAction);
begin
//bitmap.free;
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
binary_data := '';
bitmap := TBitmap.Create;
bitmap.SetSize(640, 256);
bitmap.Canvas.Brush.Color := 0;
bitmap.Canvas.FillRect(rect(0,0,640,256));
image1.Picture.Bitmap.Assign(bitmap);
image2.Canvas.Brush.Color := 0;
image2.Canvas.FillRect(Rect(0,0,image2.width,image2.height));
marker.position := 0;
marker.Fixed := true;
shift := 0;
//bitmap2 := TBitmap.Create;
threadalive := false;
dragging := false;
 {	DataThread 								:= 	Thread.Create(True);
	DataThread.FreeonTerminate:=	true;
	DataThread.zoomOut := trackbar1.Position;
	DataThread.drawQuery := false;
	DataThread.Resume;}
end;

procedure TForm1.Image1Click(Sender: TObject);
var test: integer;
begin
marker.Fixed := true;
test :=mouse.CursorPos.X - left - 3;
if abs(mouse.CursorPos.X - left - 3 - dragStart) < 3 then begin
	marker.left := getAbsolutePos(mouse.CursorPos.X - left - 2);
	marker.right := marker.left;
	dragging := false;
end;

BarPlot(mouse.CursorPos.X - left - 3 ,trunc(Math.Power(2,trackbar1.Position)*256));
end;

procedure TForm1.Image1MouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
	marker.Fixed := false;
	marker.left := getAbsolutePos(x);
	dragging := true;
	dragStart := x;
end;

procedure TForm1.Image1MouseEnter(Sender: TObject);
begin
SetFocus;
end;

procedure TForm1.Image1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
panel1.SetFocus;
if (binary_data = '') or marker.Fixed or not dragging then EXIT;
marker.right := getAbsolutePos(x);
BarPlot(x,trunc(Math.Power(2,trackbar1.Position)*256));
//SetFocus;
inherited;
end;

procedure TForm1.Image1MouseUp(Sender: TObject; Button: TMouseButton;
	Shift: TShiftState; X, Y: Integer);
begin
	if dragging then begin
		marker.Fixed := true;
		marker.right := getAbsolutePos(x);
		dragging := false;
	end;
end;

procedure TForm1.Panel2MouseUp(Sender: TObject; Button: TMouseButton;
	Shift: TShiftState; X, Y: Integer);
var zoomOut : integer;
begin
{	if (button = mbLeft) and (trackbar1.Position < trackbar1.Max) then begin
		dragging := false;
		if binary_data<>'' then begin
			unit1.shift := trunc(panel2.Left/panel1.Width*length(binary_data)/256);
			draw(trackbar1.Position);
		end;
	end;  }
	dragging := false;
	BarPlot(x,trunc(Math.Power(2,trackbar1.Position)*256));
	with panel2 do
	if left > panel1.Width - width  then
				left := panel1.Width - width
end;

procedure TForm1.SpeedButton1Click(Sender: TObject);
begin
trackbar1.Position := trackbar1.Position + 1;
end;

procedure TForm1.SpeedButton2Click(Sender: TObject);
begin
trackbar1.Position := trackbar1.Position - 1;
end;

procedure TForm1.SpeedButton3Click(Sender: TObject);
begin
trackbar1.Position := trackbar1.Max;
end;

procedure TForm1.Panel2MouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
	if button = mbLeft then begin
		dragging := true;
		getSettings;
end;
end;

procedure TForm1.Panel2MouseMove(Sender: TObject; Shift: TShiftState; X,
	Y: Integer);
var
	_left: integer;
	t0:cardinal;
begin
 if dragging then begin
		with panel2 do begin
			_left := Mouse.CursorPos.X - Form1.left - 3 - width div 2;
			if _Left < 0 then
				Left := 0
			{else
			if _left > panel1.Width - width  then
				left := panel1.Width - width  }
			else
				left := _left;
		end;
	if trackbar1.Position < trackbar1.Max then
		if binary_data<>'' then begin

			unit1.shift := trunc(panel2.Left/panel1.Width*length(binary_data)/magicConstant);
			t0 := gettickcount;
			draw(trackbar1.Position);
			//Threads.run(trackbar1.Position);
			//DataThread.drawQuery := true;
			t0 := gettickcount - t0;
			form1.Caption := 	floattostr((unit1.shift)*magicConstant/length(binary_data))+' - '+
											floattostr((unit1.shift+trunc(Math.power(2,trackbar1.Position)*640))*magicConstant/length(binary_data))+
											' - '+inttostr(t0)+'ms';

			//panel2.Left := trunc(panel1.Width*(shift*256/length(binary_data)));
			{form1.Caption := 	floattostr((unit1.shift)*256/length(binary_data))+' - '+
												floattostr((unit1.shift+trunc(Math.power(2,trackbar1.Position)*640))*256/length(binary_data))+
												' - '+intToStr(t0)+'ms'; }
	end;
 end;
end;

procedure TForm1.BarPlot(slice, blockSize: integer);
var i	:	integer;
frequency: TFrequency;
_max: int64;
scale,rest: double;
left, right, top, bottom : integer;
shift: integer;
ptr:pointer;
begin
if (binary_data = '') or (slice < 0) or (blockSize < 1) then
	EXIT;
//if slice*blockSize+blockSize > length(binary_data) then begin
 //	EXIT;
shift := unit1.shift*256;
bitmap2 := TBitmap.Create;

frequency := Frequency_Analysis(@binary_data, shift + slice*blockSize,blockSize);
_max := 0;
for i := 0 to 255 do
	if _max<frequency[i] then
		_max:=frequency[i];
if (_max <> 0) and (slice*blockSize+blockSize < length(binary_data)) then
	scale := 1 / _max
else for I := 0 to 255 do
			 frequency[i] := 0;

with bitmap2 do begin
	SetSize(image2.Width,image2.Height);
	Canvas.Brush.Color := 0;
	Canvas.FillRect(Rect(0,0,width,height));
	Canvas.Brush.Color := clBlue;
	for I := 0 to 255 do begin
		left := trunc((i)/256*width);
		top		:= height - trunc(frequency[i]*scale*(height));
		right := trunc((i+1)/256*width);
		bottom := height-1;
		Canvas.FillRect(Rect(left, top, right, bottom));
		rest := frequency[i]*scale*height;
		rest := rest - trunc(rest);
		canvas.Pen.Color := $FF7F7F;
		canvas.MoveTo( left,top-1);
		canvas.LineTo(right,top-1);
	end;
end;
Image2.Picture.Bitmap.Assign(bitmap2);
//if marker.position <> slice then begin

 {	if (marker.position > 0) then
	for I := 0 to 255 do
		bitmap.Canvas.Pixels[marker.position,i] := Column[i];}
	for I := 0 to 255 do begin
		ptr := bitmap.ScanLine[i];
		Move(ExBitmap2[i],ptr^, 640*4);
	end;
	marker.position := slice;
	left := trunc((marker.left-shift)/blockSize);
	right :=trunc((marker.right-shift)/blockSize);
	with bitmap do begin
		Canvas.Pen.Style := psdot;
		Canvas.Pen.Width := 1;
		Canvas.Pen.Mode := pmMerge;
		Canvas.Pen.Color := clYellow;
		Canvas.MoveTo(left,height);
		Canvas.LineTo(left,0);
		Canvas.MoveTo(right,height);
		Canvas.LineTo(right,0);
		Canvas.Pen.Color := $FF00FF;
		Canvas.Pen.Mode := pmmask;
		Canvas.Pen.Style := psSolid;
		I := min(left, right) + 1;
		_max := max(left, right);
		if i < 0 then
			i := 0;
		if _max > width then
			_max := width;
		while i < _max do begin
			Canvas.MoveTo(i,height);
			Canvas.LineTo(i,0);
			inc(i);
    end;
	end;
	image1.Picture.Bitmap.Assign(bitmap);
//end;
end;

end.
